#!/bin/env python3
import numpy as np
import matplotlib.pyplot as plt
from tqdm import tqdm
import os
import psutil
import gc
from mpi4py import MPI
import math

def get_memory_usage():
    """Return current process RSS memory usage in MB."""
    process = psutil.Process(os.getpid())
    return process.memory_info().rss / 1024 / 1024  # 转换为MB

comm = MPI.COMM_WORLD
rank = comm.Get_rank()
size = comm.Get_size()

def calculate_displacement(pos_initial, pos_final):
    displacement = pos_final - pos_initial
    return displacement

def read_poscar(filename, atom_index):
    """Read equilibrium position for a given atom index from POSCAR."""
    try:
        with open(filename, 'r') as f:
            lines = f.readlines()

        lattice_constants = float(lines[1])
        lattice_vectors = np.array([list(map(float, line.split())) for line in lines[2:5]])
        elements = lines[5].split()
        atom_counts = list(map(int, lines[6].split()))

        num_atoms = sum(atom_counts)
        if atom_index >= num_atoms:
            raise ValueError(f"Atom index {atom_index} out of range (0-{num_atoms-1})")

        positions = np.array([list(map(float, line.split()[:3])) for line in lines[8:8+num_atoms]])
        position = positions[atom_index]

        return lattice_constants, lattice_vectors, elements, atom_counts, position
    except Exception as e:
        print(f"Error reading POSCAR: {str(e)}")
        raise

def process_xdatcar_chunk(lines, num_atoms, chunk_size=1000):
    """Process one XDATCAR data chunk."""
    positions = []
    step_size = num_atoms + 1
    
    for i in range(0, len(lines), step_size):
        if i + step_size > len(lines):
            break
        positions_step = np.array([list(map(float, line.split())) for line in lines[i+1:i+step_size]])
        positions.append(positions_step)
        if len(positions) >= chunk_size:
            yield np.array(positions)
            positions = []
    if positions:
        yield np.array(positions)

def read_xdatcar(filename, atom_index, chunk_size=1000):
    """Stream positions for the given atom index across all steps."""
    try:
        with open(filename, 'r') as f:
            for _ in range(6):
                next(f)
            
            atom_counts = list(map(int, next(f).split()))
            num_atoms = sum(atom_counts)
            step_size = num_atoms + 1
            
            chunk_lines = []
            for line in f:
                chunk_lines.append(line)
                if len(chunk_lines) >= step_size * chunk_size:
                    for chunk in process_xdatcar_chunk(chunk_lines, num_atoms, chunk_size):
                        yield chunk[:, atom_index]
                    chunk_lines = []
                    gc.collect()
            
            if chunk_lines:
                for chunk in process_xdatcar_chunk(chunk_lines, num_atoms, chunk_size):
                    yield chunk[:, atom_index]
                    
    except Exception as e:
        print(f"Error reading XDATCAR: {str(e)}")
        raise

def write_poscar_avg(filename, lattice_constants, lattice_vectors, elements, atom_counts, positions):
    """Write averaged positions to POSCAR-like file."""
    try:
        with open(filename, 'w') as f:
            f.write("generated by positions.py\n")
            f.write(f"    {lattice_constants}\n")
            for vec in lattice_vectors:
                f.write(f"    {vec[0]:20.16f} {vec[1]:20.16f} {vec[2]:20.16f}\n")
            f.write(" ".join(elements) + "\n")
            f.write(" ".join(map(str, atom_counts)) + "\n")
            f.write("Direct\n")
            for pos in positions:
                f.write(f"{pos[0]:20.16f} {pos[1]:20.16f} {pos[2]:20.16f}\n")
    except Exception as e:
        print(f"Error writing POSCAR_AVG: {str(e)}")
        raise

def process_atom_chunk(atom_indices, poscar_file, xdatcar_file, chunk_size=1000):
    """Compute average positions for a set of atom indices."""
    results = []
    for atom_index in atom_indices:
        _, _, _, _, pos_initial = read_poscar(poscar_file, atom_index)
        
        total_displacement = np.zeros(3)
        count = 0
        
        for positions_chunk in read_xdatcar(xdatcar_file, atom_index, chunk_size):
            displacements = calculate_displacement(pos_initial, positions_chunk)
            
            for i in range(3):
                mask = displacements[:, i] > 0.5
                displacements[mask, i] -= 1.0
            
            total_displacement += np.sum(displacements, axis=0)
            count += len(displacements)
            
            if count % (chunk_size * 10) == 0:
                gc.collect()
        
        avg_displacement = total_displacement / count
        
        avg_displacement[np.abs(avg_displacement) < 0.00001] = 0
        
        avg_position = pos_initial + avg_displacement
        avg_position %= 1.0
        results.append((atom_index, avg_position))
        
        if atom_index % 100 == 0:
            print(f"Rank {rank}: processed atom {atom_index}, memory: {get_memory_usage():.2f} MB")
    
    return results

def main():
    poscar_file = "POSCAR"
    xdatcar_file = "XDATCAR"
    output_file = "POSCAR_AVG"
    chunk_size = 1000

    if rank == 0:
        print(f"Initial memory: {get_memory_usage():.2f} MB")
        print(f"Running with {size} MPI processes")

    lattice_constants, lattice_vectors, elements, atom_counts, _ = read_poscar(poscar_file, 0)
    num_atoms = sum(atom_counts)
    
    atoms_per_process = math.ceil(num_atoms / size)
    start_idx = rank * atoms_per_process
    end_idx = min((rank + 1) * atoms_per_process, num_atoms)
    local_atom_indices = list(range(start_idx, end_idx))
    
    local_results = process_atom_chunk(local_atom_indices, poscar_file, xdatcar_file, chunk_size)
    
    all_results = comm.gather(local_results, root=0)
    
    if rank == 0:
        avg_positions = [None] * num_atoms
        for process_results in all_results:
            for atom_index, position in process_results:
                avg_positions[atom_index] = position
        
        write_poscar_avg(output_file, lattice_constants, lattice_vectors, elements, atom_counts, avg_positions)
        print(f"Done. Results saved to {output_file}")
        print(f"Final memory: {get_memory_usage():.2f} MB")

if __name__ == "__main__":
    main()
